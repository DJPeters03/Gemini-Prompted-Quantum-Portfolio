<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Two Qubit & Entanglement Simulator</title>
    <style>
        body { font-family: sans-serif; background: #0f0f13; color: #fff; display: flex; flex-direction: column; align-items: center; padding: 20px;}
        .system { display: flex; gap: 40px; flex-wrap: wrap; justify-content: center; }
        .qubit-wrapper { text-align: center; }
        canvas { background: #000; border: 1px solid #333; border-radius: 50%; cursor: grab; }
        .controls-row { display: flex; gap: 10px; margin-top: 10px; justify-content: center; }
        .multi-gate-row { margin-top: 20px; padding: 20px; background: #1a1a20; border-radius: 10px; text-align: center; border: 1px solid #333; }
        button { padding: 8px 12px; cursor: pointer; border: none; border-radius: 4px; background: #333; color: white; font-weight: bold;}
        button:hover { background: #555; }
        button.cnot { background: #6f42c1; }
        button.reset { background: #d9534f; margin-top: 20px; padding: 10px 30px; font-size: 1.1em;}
        
        .bars { display: flex; gap: 20px; margin-top: 30px; width: 100%; max-width: 600px; height: 150px; align-items: flex-end; }
        .bar-container { flex: 1; text-align: center; }
        .bar { background: #00d4ff; width: 100%; transition: height 0.3s; border-top-left-radius: 5px; border-top-right-radius: 5px; min-height: 1px;}
        .label { margin-top: 5px; font-family: monospace; }
        
        .note { max-width: 600px; color: #aaa; margin-top: 20px; font-size: 0.9em; background: #222; padding: 10px; border-left: 3px solid #6f42c1;}
    </style>
</head>
<body>

    <h1>2-Qubit Entanglement Calculator</h1>

    <div class="system">
        <div class="qubit-wrapper">
            <h3>Qubit A</h3>
            <canvas id="c1" width="250" height="250"></canvas>
            <div class="controls-row">
                <button onclick="applySingleGate(0, 'X')">X</button>
                <button onclick="applySingleGate(0, 'H')">H</button>
                <button onclick="applySingleGate(0, 'Z')">Z</button>
            </div>
        </div>

        <div class="qubit-wrapper">
            <h3>Qubit B</h3>
            <canvas id="c2" width="250" height="250"></canvas>
            <div class="controls-row">
                <button onclick="applySingleGate(1, 'X')">X</button>
                <button onclick="applySingleGate(1, 'H')">H</button>
                <button onclick="applySingleGate(1, 'Z')">Z</button>
            </div>
        </div>
    </div>

    <div class="multi-gate-row">
        <h3>Entangling Gates (2-Qubit)</h3>
        <button class="cnot" onclick="applyCNOT()">CNOT (Control: A, Target: B)</button>
        <button class="cnot" onclick="applySWAP()">SWAP</button>
    </div>

    <button class="reset" onclick="resetSystem()">Reset System</button>

    <div class="bars">
        <div class="bar-container"><div class="bar" id="b00"></div><div class="label">|00⟩</div></div>
        <div class="bar-container"><div class="bar" id="b01"></div><div class="label">|01⟩</div></div>
        <div class="bar-container"><div class="bar" id="b10"></div><div class="label">|10⟩</div></div>
        <div class="bar-container"><div class="bar" id="b11"></div><div class="label">|11⟩</div></div>
    </div>

    <div class="note">
        <strong>Note:</strong> If the arrows inside the spheres shrink or disappear, the qubits are 
        <strong>Entangled</strong>. When entangled, a single qubit does not have its own defined state vector, 
        so the Bloch vector length drops to 0. Use the bar chart to see the system state.
    </div>

<script>
// --- Complex Math Engine ---
class Complex {
    constructor(re, im) { this.re = re; this.im = im; }
    add(c) { return new Complex(this.re + c.re, this.im + c.im); }
    mul(c) { return new Complex(this.re * c.re - this.im * c.im, this.re * c.im + this.im * c.re); }
    magSq() { return this.re * this.re + this.im * this.im; }
}

// State Vector: |00>, |01>, |10>, |11>
// Initial state: |00> -> [1, 0, 0, 0]
let qState = [new Complex(1,0), new Complex(0,0), new Complex(0,0), new Complex(0,0)];

// Gates
const GATES = {
    'X': [[0,1], [1,0]],
    'Z': [[1,0], [0,-1]],
    'H': [[0.7071, 0.7071], [0.7071, -0.7071]]
};

// --- Logic ---

// Apply gate to single qubit (tensor product logic simplified)
function applySingleGate(qubitIndex, gateName) {
    const g = GATES[gateName];
    // We need to construct the 4x4 matrix or apply manually
    // To keep code short, we calculate new amplitudes directly based on indices
    let newState = [new Complex(0,0), new Complex(0,0), new Complex(0,0), new Complex(0,0)];
    
    // Matrix elements (real only for standard gates used here)
    let u00 = g[0][0], u01 = g[0][1], u10 = g[1][0], u11 = g[1][1];

    if(qubitIndex === 0) {
        // Gate on Q1 (MSB). Indices: 0->0&2, 1->1&3
        // Pair (0, 2) and (1, 3)
        // |0x> pairs with |1x>
        for(let i of [0, 1]) {
            let idx0 = i;     // 00 or 01
            let idx1 = i + 2; // 10 or 11
            
            let a = qState[idx0];
            let b = qState[idx1];
            
            // Standard matrix mult
            newState[idx0] = a.mul(new Complex(u00,0)).add(b.mul(new Complex(u01,0)));
            newState[idx1] = a.mul(new Complex(u10,0)).add(b.mul(new Complex(u11,0)));
        }
    } else {
        // Gate on Q2 (LSB). Indices: 0->0&1, 2->2&3
        for(let i of [0, 2]) {
            let idx0 = i;
            let idx1 = i + 1;
            
            let a = qState[idx0];
            let b = qState[idx1];
            
            newState[idx0] = a.mul(new Complex(u00,0)).add(b.mul(new Complex(u01,0)));
            newState[idx1] = a.mul(new Complex(u10,0)).add(b.mul(new Complex(u11,0)));
        }
    }
    qState = newState;
    updateUI();
}

function applyCNOT() {
    // Control Q1 (MSB), Target Q2 (LSB)
    // Swaps amplitudes of |10> and |11> (Indices 2 and 3)
    let temp = qState[2];
    qState[2] = qState[3];
    qState[3] = temp;
    updateUI();
}

function applySWAP() {
    // Swaps |01> and |10> (Indices 1 and 2)
    let temp = qState[1];
    qState[1] = qState[2];
    qState[2] = temp;
    updateUI();
}

function resetSystem() {
    qState = [new Complex(1,0), new Complex(0,0), new Complex(0,0), new Complex(0,0)];
    updateUI();
}

// --- Reduced Density Matrix Calculation ---
// To draw the arrow on the sphere for Qubit A, we must "trace out" Qubit B.
function getBlochVector(qubitIndex) {
    // Density Matrix Rho
    // We need expectations <X>, <Y>, <Z>
    // Simplified:
    // If state = a|00> + b|01> + c|10> + d|11>
    let a = qState[0], b = qState[1], c = qState[2], d = qState[3];

    let x, y, z;

    if (qubitIndex === 0) { // Qubit A
        // Z = P(0) - P(1) = (|a|^2 + |b|^2) - (|c|^2 + |d|^2)
        z = (a.magSq() + b.magSq()) - (c.magSq() + d.magSq());
        
        // X = 2Re(ac* + bd*)
        let ac = a.mul(new Complex(c.re, -c.im));
        let bd = b.mul(new Complex(d.re, -d.im));
        x = 2 * (ac.re + bd.re);

        // Y = 2Im(ac* + bd*)
        y = 2 * (ac.im + bd.im);
    } else { // Qubit B
        // Z = (|a|^2 + |c|^2) - (|b|^2 + |d|^2)
        z = (a.magSq() + c.magSq()) - (b.magSq() + d.magSq());
        
        // X = 2Re(ab* + cd*)
        let ab = a.mul(new Complex(b.re, -b.im));
        let cd = c.mul(new Complex(d.re, -d.im));
        x = 2 * (ab.re + cd.re);
        
        // Y = 2Im(ab* + cd*)
        y = 2 * (ab.im + cd.im);
    }
    
    return {x, y, z};
}

// --- Visualization ---
const canvases = [document.getElementById('c1'), document.getElementById('c2')];
const ctxs = canvases.map(c => c.getContext('2d'));
let viewAngle = { x: 0.5, y: 0.5 }; 

function project(x, y, z) {
    let x1 = x * Math.cos(viewAngle.y) - z * Math.sin(viewAngle.y);
    let z1 = x * Math.sin(viewAngle.y) + z * Math.cos(viewAngle.y);
    let y2 = y * Math.cos(viewAngle.x) - z1 * Math.sin(viewAngle.x);
    return { x: x1 * 70 + 125, y: -y2 * 70 + 125 };
}

function drawSphere(ctx, vect) {
    ctx.clearRect(0,0,250,250);
    ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
    
    // Wireframe
    for(let i=0; i<Math.PI; i+=0.4) {
        ctx.beginPath();
        for(let j=0; j<2*Math.PI; j+=0.2) {
            let p = project(Math.sin(j)*Math.cos(i), Math.cos(j), Math.sin(j)*Math.sin(i));
            if(j==0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    }
    
    const center = project(0,0,0);
    const end = project(vect.x, vect.y, vect.z);
    
    // Arrow
    // If length is near 0 (Entangled), make it gray and dotted or just short
    let len = Math.sqrt(vect.x**2 + vect.y**2 + vect.z**2);
    
    ctx.strokeStyle = len < 0.9 ? '#555' : '#ff0055'; // Gray if entangled/mixed
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(center.x, center.y); ctx.lineTo(end.x, end.y); ctx.stroke();
    
    ctx.fillStyle = ctx.strokeStyle;
    ctx.beginPath(); ctx.arc(end.x, end.y, 4, 0, 2*Math.PI); ctx.fill();
}

function updateUI() {
    // Draw Spheres
    drawSphere(ctxs[0], getBlochVector(0));
    drawSphere(ctxs[1], getBlochVector(1));

    // Update Bars
    const probs = qState.map(c => c.magSq());
    document.getElementById('b00').style.height = (probs[0]*100) + '%';
    document.getElementById('b01').style.height = (probs[1]*100) + '%';
    document.getElementById('b10').style.height = (probs[2]*100) + '%';
    document.getElementById('b11').style.height = (probs[3]*100) + '%';
}

// Simple Drag logic for both
canvases.forEach(c => {
    let drag=false; let lx=0, ly=0;
    c.addEventListener('mousedown', e=>{drag=true; lx=e.offsetX; ly=e.offsetY;});
    window.addEventListener('mouseup', ()=>drag=false);
    c.addEventListener('mousemove', e=>{
        if(!drag)return;
        viewAngle.y += (e.offsetX-lx)*0.01;
        viewAngle.x += (e.offsetY-ly)*0.01;
        lx=e.offsetX; ly=e.offsetY;
        updateUI();
    });
});

updateUI();

</script>
</body>
</html>
